require('dotenv').config();
const express = new require('express')
const router = express.Router()
const multer  = require('multer')
const WshcmForm  = require('../schema/wshcmFormSchema')
// const PDFDocument = require('pdfkit'); // no need
// const { PDFDocument, StandardFonts } = require('pdf-lib');

const Json2csvParser = require('json2csv').Parser;

// const nodemailer = require('nodemailer');
const ejs = require('ejs');
const pdf = require('html-pdf')
const fs = require('fs')
const path = require('path')

const { google } = require('googleapis');
const apiKeys = require('./googleApiKey.json')

const SCOPE = ['https://www.googleapis.com/auth/drive'];
// A Function that can provide access to google drive api
async function authorize(){
    const jwtClient = new google.auth.JWT(
      apiKeys.client_email,
        null,
        apiKeys.private_key,
        SCOPE
    );
    await jwtClient.authorize();
    return jwtClient;
}

async function deleteFile(authClient, fileId) {
  const drive = google.drive({ version: 'v3', auth: authClient });
  try {
    await drive.files.delete({ fileId });
    console.log(`File with ID ${fileId} deleted successfully.`);
  } catch (error) {
    console.error('Error deleting file:', error);
  }
}

// A Function that will upload the desired file to google drive folder

// folder id = 1k0JF9dMxTV-97il_aaqSkSgsy2aIxb5b
async function uploadPdf(authClient){
  return new Promise((resolve,rejected)=>{
      const drive = google.drive({version:'v3',auth:authClient}); 
      var fileMetaData = {
          name:'certificate.pdf',    
          parents:['1k0JF9dMxTV-97il_aaqSkSgsy2aIxb5b'] // A folder ID to which file will get uploaded
      }
      drive.files.create({
          resource:fileMetaData,
          media:{
              body: fs.createReadStream('files/1719392663792.pdf'), // files that will get uploaded
              mimeType:'application/pdf'
          },
          fields:'id'
      },function(error,file){
          if(error){
              return rejected(error)
          }
          resolve(file);
      })
  });
}



router.get('/uploadFile' , async(req, res)=>{
  console.log("Hello sending")
  authorize().then(uploadPdf).catch("error",console.error()); 
  console.log("Hello sent")
  res.send("send successfully")
})



//mail

// const filesDir = path.join(__dirname, 'files');
// if (!fs.existsSync(filesDir)) {
//     fs.mkdirSync(filesDir, { recursive: true });
// }
    


// const storage = multer.diskStorage({
//     destination: function (req, file, cb) {
//             cb(null, 'files')
//     },
//     filename: function (req, file, cb) {
//             const uniqueSuffix = Date.now()
//             cb(null,uniqueSuffix + file.originalname)
//     }
// })



// const upload = multer({ storage: storage })




router.get("/fetchWshcmForms" , async(req,res)=>{
 
    try{
      let WshcmFormData = await WshcmForm.find();
      const wshcmFormSchemaFields = Object.keys(WshcmForm.schema.obj);
      const schemaFieldsWithTypes = WshcmForm.schema.obj;
      res.send({status : 1 , message:"Welcome to Product Page" , WshcmFormData : WshcmFormData , wshcmFormSchemaFields : wshcmFormSchemaFields , schemaFieldsWithTypes: schemaFieldsWithTypes});  

    }catch(err){
      res.send({status : 0 , message : "Error occured in wschm from fetch"})
    }


})


// router.post("/submitForm", upload.fields([{ name: 'certificateFiles', maxCount: 12 }, { name: 'photo', maxCount: 1 }]), async (req, res) => {
//     try{

//         // console.table(req.body)

//         const certificateFiles = req.files['certificateFiles'].map(file => file.filename);
//         // For single file, use req.file
//         const photo = req.files['photo'][0].filename;


//       const newForm = new WshcmForm({
//         class_type: req.body.class_type,
//         participantName: req.body.participantName,
//         NRIC_No: req.body.NRIC_No,
//         organization: req.body.organization,
//         date_of_birth: req.body.date_of_birth, // Assuming date format is handled appropriately
//         sunday_class_timing: req.body.sunday_class_timing,
//         work_permit: req.body.work_permit,
//         work_permit_expiry: req.body.work_permit_expiry, // Assuming date format is handled appropriately
//         working_day_timing: req.body.working_day_timing,
//         contact_no: req.body.contact_no,
//         identification: req.body.identification,
//         companyName: req.body.companyName,
//         companyUEN: req.body.companyUEN,
//         companyPersonName: req.body.companyPersonName,
//         companyPersonEmail: req.body.companyPersonEmail,
//         companyPersonContactNo: req.body.companyPersonContactNo,
//         email_id: req.body.email_id,
//         experience: req.body.experience,
//         salary: req.body.salary,
//         qualifications: req.body.qualifications,
//         gender: req.body.gender,
//         nationality: req.body.nationality,
//         race: req.body.race,
      
//         // Handle certificate files (assuming an array of filenames in req.body.certificateFiles)
//         certificateFiles: req.body.certificateFiles ? req.body.certificateFiles : [],
      
//         // Handle photo filename (assuming a single filename in req.body.photo)
//         photo: req.body.photo,
//       });

//       const response = await newForm.save();

      
//     res.send({status : 1 , message : "Successfully received"})


//     } catch(err){
//         console.log("Something went wrong");
//         res.send({status : 0 , message : "Something went wrong"})
//     }
    
// });


// function isValidDate(dateString) {
//     // Regex pattern for YYYY-MM-DD format
//     const regex = /^\d{4}-\d{2}-\d{2}$/;
  
//     // Check if the date string matches the format
//     if (!regex.test(dateString)) {
//       return false;
//     }
  
//     // Split the date string into year, month, and day components
//     const parts = dateString.split('-');
//     const year = parseInt(parts[0], 10);
//     const month = parseInt(parts[1], 10) - 1; // Months are 0-indexed
//     const day = parseInt(parts[2], 10);
  
//     // Check for valid date ranges (considering leap years)
//     return new Date(year, month, day).getTime() !== NaN &&
//            (year >= 1900 && year <= new Date().getFullYear());
//   }


function validateFileSize(file) {
    const fileSizeLimit = 30 * 1024 * 1024; // 30MB in bytes
    return file.size <= fileSizeLimit;
  }
  
  // Configure Multer storage with file size validation
  const storage = multer.diskStorage({
    destination: function (req, file, cb) {
      cb(null, 'files'); // Adjust 'files' as needed for your file storage location
    },
    filename: function (req, file, cb) {
      const uniqueSuffix = Date.now() + path.extname(file.originalname);
      cb(null, uniqueSuffix);
    },
    limits: { fileSize: validateFileSize },
  });

const upload = multer({ storage: storage })
 






// const submitForm = async(req,res) =>{

router.post("/submitForm", upload.fields([{ name: 'certificateFiles', maxCount: 12 }, { name: 'photo', maxCount: 1 }]), async (req, res) => {
    try {
      // Comprehensive validation
      const validationErrors = [];
  
      // Class type (required, string)
      if (!req.body.class_type || typeof req.body.class_type !== 'string') {
        validationErrors.push('"class_type" is required and must be a string.');
      }

      
      // Participant name (required, string)
      if (!req.body.participantName || typeof req.body.participantName !== 'string') {
          validationErrors.push('"participantName" is required and must be a string.');
        }
        
        // NRIC_No (optional, string)
        if (req.body.NRIC_No && typeof req.body.NRIC_No !== 'string') {
            validationErrors.push('"NRIC_No" must be a string if provided.');
        }
        
        // Organization (required, string)
        if (!req.body.organization || typeof req.body.organization !== 'string') {
            validationErrors.push('"organization" is required and must be a string.');
        }
        
        // Date of birth (required, valid date format)
        //   if (!req.body.date_of_birth || !isValidDate(req.body.date_of_birth)) {
    //     validationErrors.push('"date_of_birth" is required and must be a valid date format.');
    //   }
  
      // Sunday class timing (required, string)
      if (req.body.sunday_class_timing && typeof req.body.sunday_class_timing !== 'string' || req.body.work_permit && typeof req.body.work_permit !== 'string' ) {
        validationErrors.push('"sunday_class_timing" is required and must be a string or "work_permit" must be a string if provided.');
      }
  
      // Work permit (optional, string)
    //   if () {
    //     validationErrors.push('');
    //   }
  
      // Work permit expiry (optional, valid date format if work permit is provided)
    //   if (req.body.work_permit && (!req.body.work_permit_expiry || !isValidDate(req.body.work_permit_expiry))) {
    //     validationErrors.push('"work_permit_expiry" is required and must be a valid date format if "work_permit" is provided.');
    //   }
  
      // Working day timing (required, string)
      // if (!req.body.working_day_timing || typeof req.body.working_day_timing !== 'string') {
      //   validationErrors.push('"working_day_timing" is required and must be a string.');
      // }
  
      // Contact number (required, string)
      if (!req.body.contact_no || typeof req.body.contact_no !== 'string') {
        validationErrors.push('"contact_no" is required and must be a string.');
      }
  
      // Identification (required, string)
      if (!req.body.identification || typeof req.body.identification !== 'string') {
        validationErrors.push('"identification" is required and must be a string.');
      }
  
      // Company name (required, string)
      if (!req.body.companyName || typeof req.body.companyName !== 'string') {
        validationErrors.push('"companyName" is required and must be a string.');
      }
  
      // Company UEN (optional, string)
      if (req.body.companyUEN && typeof req.body.companyUEN !== 'string') {
        validationErrors.push('"companyUEN" must be a string if provided.');
      }
  
      // Company person name (required, string)
      if (!req.body.companyPersonName || typeof req.body.companyPersonName !== 'string') {
          validationErrors.push('"companyPersonName" is required and must be a string.');
      }
  
      // Company person email (required, string)
      if (!req.body.companyPersonEmail || typeof req.body.companyPersonEmail !== 'string') {
        validationErrors.push('"companyPersonEmail" is required and must be a string.');
      }

      // Company person contact number (optional, string)
        if (req.body.companyPersonContactNo && typeof req.body.companyPersonContactNo !== 'string') {
            validationErrors.push('"companyPersonContactNo" must be a string if provided.');
        }
        
        // Email ID (required, string)
        if (!req.body.email_id || typeof req.body.email_id !== 'string') {
            validationErrors.push('"email_id" is required and must be a string.');
        }
        
        // Experience (optional, string)
        if (req.body.experience && typeof req.body.experience !== 'string') {
            validationErrors.push('"experience" must be a string if provided.');
        }
        
        // Salary (optional, number)
        // if (req.body.salary && (typeof req.body.salary !== 'number' || isNaN(req.body.salary))) {
        //     validationErrors.push('"salary" must be a number if provided.');
        // }
        
        // Qualifications (optional, string)
        if (req.body.qualifications && typeof req.body.qualifications !== 'string') {
            validationErrors.push('"qualifications" must be a string if provided.');
        }
        
        // Gender (optional, string)
        if (req.body.gender && typeof req.body.gender !== 'string') {
            validationErrors.push('"gender" must be a string if provided.');
        }
        
        // Nationality (optional, string)
        if (req.body.nationality && typeof req.body.nationality !== 'string') {
            validationErrors.push('"nationality" must be a string if provided.');
        }
        
        // Race (optional, string)
        if (req.body.race && typeof req.body.race !== 'string') {
            validationErrors.push('"race" must be a string if provided.');
        }
        


        // const uploadResult = await upload.fields([
        //     { name: 'certificateFiles', maxCount: 12 },
        //     { name: 'photo', maxCount: 1 },
        //   ])(req, res, (err) => {
        //     if (err) {
        //       console.error(err);
        //       return res.status(500).send({ status: 0, message: "Internal server error" });
        //     }
      
        //     // Continue with processing the request after successful upload
        //     // Access uploaded files through req.files
        //   });
        

        
        // Validate certificate files
    if (req.files['certificateFiles']) {
        for (const file of req.files['certificateFiles']) {
          if (!validateFileSize(file)) {
            validationErrors.push(`Certificate file "${file.originalname}" exceeds the maximum size of 30MB.`);
          }
        }
      }
  
      // Validate photo file size
      if (req.files['photo'] && !validateFileSize(req.files['photo'][0])) {
        validationErrors.push(`Photo file exceeds the maximum size of 30MB.`);
      }
  



    
    if (validationErrors.length > 0) {
        // If there are validation errors, return a bad request with the errors
        return res.status(400).send({ status: 0, message: 'Validation errors:', errors: validationErrors });
    }
    
    
  

        const certificateFiles = req.files['certificateFiles'].map(file => file.filename);
        // For single file, use req.file
        const photo = req.files['photo'][0].filename;


      
      // Create a new form instance
      const newForm = new WshcmForm({
        class_type: req.body.class_type,
        participantName: req.body.participantName,
        NRIC_No: req.body.NRIC_No,
        organization: req.body.organization,
        date_of_birth: req.body.date_of_birth, // Assuming date format is handled appropriately
        sunday_class_timing: req.body.sunday_class_timing,
        work_permit: req.body.work_permit,
        work_permit_expiry: req.body.work_permit_expiry, // Assuming date format is handled appropriately
        working_day_timing: req.body.working_day_timing,
        contact_no: req.body.contact_no,
        identification: req.body.identification,
        companyName: req.body.companyName,
        companyUEN: req.body.companyUEN,
        companyPersonName: req.body.companyPersonName,
        companyPersonEmail: req.body.companyPersonEmail,
        companyPersonContactNo: req.body.companyPersonContactNo, // Assuming this field exists
        email_id: req.body.email_id,
        experience: req.body.experience,
        salary: req.body.salary,
        qualifications: req.body.qualifications,
        gender: req.body.gender,
        nationality: req.body.nationality,
        race: req.body.race,
        certificateFiles: certificateFiles,
      
        photo: photo,
        
      });

      // certificateFiles,
        // photo,
  
      const response = await newForm.save();

      if (response.error) {
        // Handle custom error object or message returned by newForm.save()
        return res.status(400).send({ status: 0, message: response.error });
      }
      
      res.send({ status: 1, message: "Successfully received" });
      console.log("check 1")
       // Include saved data in response (optional)
    } catch (err) {
      console.error(err); // Log the error for debugging
      res.status(500).send({ status: 0, message: "Internal server error" });
    }
});



// router.get('/exportFormPdf', async(req,res)=>{
//   try {
//     const data = await WshcmForm.find({}); // Fetch all data from your wshcmForm collection

//     // Prepare table data for PDF generation
//     const formattedData = data.map(row => ({
//       'class_type': row.class_type,
//       'participantName': row.participantName,
//       'NRIC_No': row.NRIC_No,
//       'organization': row.organization,
//       'date_of_birth': row.date_of_birth,
//       'sunday_class_timing': row.sunday_class_timing,
//       'work_permit': row.work_permit,
//       'work_permit_expiry': row.work_permit_expiry,
//       'working_day_timing': row.working_day_timing,
//       'contact_no': row.contact_no,
//       'identification': row.identification,
//       'companyName': row.companyName,
//       'companyUEN': row.companyUEN,
//       'companyPersonName': row.companyPersonName,
//       'companyPersonEmail': row.companyPersonEmail,
//       'companyPersonContactNo': row.companyPersonContactNo,
//       'email_id': row.email_id,
//       'experience': row.experience,
//       'salary': row.salary,
//       'qualifications': row.qualifications,
//       'gender': row.gender,
//       'nationality': row.nationality,
//       'race': row.race,
//       // Include certificateFiles and photo if you want them in the PDF (see note below)
//       // 'certificateFiles': row.certificateFiles, // Not recommended for large files
//       // 'photo': row.photo, // Not recommended for images
//     }));

//     generatePDF(formattedData); // Pass the formatted data to PDF generation
//     res.send('PDF generated successfully!');
//   } catch (err) {
//     console.error(err);
//     res.status(500).send('Error generating PDF');
//   }
// })

// function generatePDF(data) {
//   const doc = new PDFDocument();

//   // Add title and headers
//   doc.text('Your Table Data Report');
//   doc.text('---------------------', { underline: true });

//   // Add table headers
//   const wshcmFormSchemaFields = Object.keys(WshcmForm.schema.obj);
//   const tableHeaders = wshcmFormSchemaFields.map(field => field.replace(/_/g, ' ').toUpperCase());

//   // const tableHeaders = ['Field 1', 'Field 2', /* ... other headers */];
//   doc.fontSize(12).text(tableHeaders.join('  |  '), { align: 'center' });
//   doc.moveDown(5);
//   doc.lineTo(0, doc.y + 2) .stroke(); // Add line under headers

//   // Loop through data and add rows
//   data.forEach(row => {
//     doc.fontSize(10).text(`${row.field1}  |  ${row.field2}  |  `, { align: 'left' }); // Adjust spacing as needed
//   });

//   // Save the PDF
//   doc.pipe(fs.createWriteStream('./exportedPdfs/userForms.pdf')).end();
// }



router.get('/exportFormPdf', async(req,res)=>{
  try{

      console.log("Hello")
      const formDoc = await WshcmForm.find();
      const data = {
          formDoc : formDoc,
      };

      const filePathName = path.resolve(__dirname , '../ejs_file/htmltopdf.ejs');
      const htmlString = fs.readFileSync(filePathName).toString();
      const options = {
        format: 'A2',
        orientation: 'landscape',
        margin: 0, // Set all margins to 0
        childProcessOptions: {
          env: { OPENSSL_CONF: '/dev/null' },
        },
      }  
      const ejsData = ejs.render(htmlString , data);
      pdf.create(ejsData, options).toFile('./exportedPdfs/userForms.pdf', (err, response) => {
          if (err) {
              console.log("Error->>>>>>>>>", err);
              res.status(500).send(err);
          } else {
              console.log('File generated');
              res.send({ filePath: 'userForms.pdf' }); // Send the file path
          }
      });
     
  }catch(err){
      console.log(err.message)
      res.send({status : 0 , message : err.message})
  }
})


router.get("/exportSingleRecordPdf/:id",async(req , res)=>{
  const formId = req.params.id;
  const formDoc = await WshcmForm.findById(formId);

  const data = {
    data : formDoc,
};
  console.log("data retrieved:", data);

  if(data){
    const filePathName = path.resolve(__dirname , '../ejs_file/individualDocAsPdf.ejs');
      const htmlString = fs.readFileSync(filePathName).toString();
      const options = {
        format: 'Letter',
        childProcessOptions: {
          env: { OPENSSL_CONF: '/dev/null' },
        },
      }  
      const ejsData = ejs.render(htmlString , data);



      pdf.create(ejsData, options).toFile('./exportedPdfs/individualRecord.pdf', (err, response) => {
          if (err) {
              console.log("Error->>>>>>>>>", err);
              res.status(500).send(err);
          } else {
              console.log('File generated');
              res.send({ filePath: 'individualRecord.pdf' }); // Send the file path
          }
      });
  }

})


router.get('/exportFormCsv', async(req,res)=>{
  try{

    console.log("hello")


    const data = await WshcmForm.find();

    // Configure CSV parser with desired fields (adjust as needed)
    const fields = [
      'class_type',
      'participantName',
      'NRIC_No',
      'organization',
      'date_of_birth',
      'sunday_class_timing',
      'work_permit',
      'work_permit_expiry',
      'working_day_timing',
      'contact_no',
      'identification',
      'companyName',
      'companyUEN',
      'companyPersonName',
      'companyPersonEmail',
      'companyPersonContactNo',
      'email_id',
      'experience',
      'salary',
      'qualifications',
      'gender',
      'nationality',
      'race',
      // Include certificateFiles and photo if needed (adjust format)
      'certificateFiles',
      'photo',
    ];
    const csvParser = new Json2csvParser({ fields });

    // Convert data to CSV string
    const csvData = csvParser.parse(data);

    // Set CSV response headers for download
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename=wshcm-forms.csv');

    // Send CSV data as response
    res.send(csvData);

     
     
  }catch(err){
      console.log(err.message)
      res.send({status : 0 , message : err.message})
  }
})


router.delete('/delete-all', async (req, res) => {
  try {
    const deletedCount = await WshcmForm.deleteMany({}); // Delete all documents
    res.json({ message: `Deleted ${deletedCount} forms` });
  } catch (err) {
    console.error(err);
    res.status(500).send('Error deleting forms');
  }
});




module.exports = router

// module.exports = submitForm;